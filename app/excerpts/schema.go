package excerpts

import (
	"github.com/mahesh-hegde/dhee/app/common"
	"github.com/mahesh-hegde/dhee/app/config"
	"github.com/mahesh-hegde/dhee/app/dictionary"
)

type Modifier string

type WordGlossing struct {
	Surface      string     `json:"surface"`
	Lemma        string     `json:"lemma"`
	Gramm        string     `json:"gramm"`
	Case         string     `json:"case,omitempty"`
	Number       string     `json:"number,omitempty"`
	Gender       string     `json:"gender,omitempty"`
	Tense        string     `json:"tense,omitempty"`
	Voice        string     `json:"voice,omitempty"`
	Person       string     `json:"person,omitempty"`
	Mood         string     `json:"mood,omitempty"`
	Root         string     `json:"root,omitempty"`
	Modifiers    []Modifier `json:"modifiers,omitempty"`
	Constituents []string   `json:"constituents,omitempty"`
}

type PadaElement struct {
	Word            string
	Found           bool
	ExactMatched    bool
	G               WordGlossing
	Slp1NormLemma   string
	Slp1NormSurface string
	SurfaceMeaning  dictionary.DictionaryEntry
	LemmaMeaning    dictionary.DictionaryEntry
}

type Auxiliary struct {
	Text []string `json:"text"`
}

type ExternalLink struct {
	Url  string `json:"url"`
	Name string `json:"name"`
}

type Related struct {
	Scripture             string   `json:"scripture"`
	ReadableIndex         string   `json:"readable_index"`
	CosineSimilarity      *float32 `json:"embedding_relevance_score,omitempty"`
	TextualRelevanceScore *float32 `json:"textual_relevance_score,omitempty"`
	AutoGenerated         bool     `json:"auto_generated"`
}

type SearchParams struct {
	// name of scriptures to search
	Scriptures []string
	Mode       common.SearchMode
	Q          string
	OriginalQ  string
	Tl         string
	// Name of auxiliary, or "0" for sanskrit text, or "1" for roman text. Empty implies all auxiliaries, roman and source text
	SearchIn []string
}

// Excerpt represents a single atomic unit from the source text. Eg: a Rik in case of Rigveda.
type Excerpt struct {
	Scripture string `json:"scripture,omitempty"`
	// Eg: "4.30.1". Autocomputed from path if does not exist.
	ReadableIndex string `json:"readable_index"`
	// Hierarchical path in the document. Eg: mandala 4 hymn 30 verse 1 will be [4,30,1].
	Path []int `json:"path"`
	// Source text in original language
	SourceText []string `json:"source_text"`
	// Romanized text (eg: IAST)
	RomanText []string `json:"roman_text"`
	// Romanized text stored as keyword in bleve for regex queries
	RomanTextK string `json:"roman_text_k"`
	RomanTextF string `json:"roman_text_f"`
	// Authors to whom the verse is attributed
	Authors []string `json:"authors,omitempty"`
	Meter   string   `json:"meter,omitempty"`
	// Complex type. 2D array with each row corresponding to one division of the verse.
	Glossings [][]WordGlossing `json:"glossings,omitempty"`
	// Translations and alternative renderings
	Auxiliaries       map[string]Auxiliary `json:"auxiliaries,omitempty"`
	Notes             []string             `json:"notes,omitempty"`
	Group             string               `json:"group,omitempty"`
	Addressees        []string             `json:"addressees,omitempty"`
	Links             []ExternalLink       `json:"links,omitempty"`
	Suggested         []Related            `json:"suggested,omitempty"`
	SuggestedSemantic []Related            `json:"suggested_semantic,omitempty"`
	SuggestedTextual  []Related            `json:"suggested_textual,omitempty"`
}

// ExcerptInDB is the type sent to bleve, with the content of main excerpt serialized without indexing,
// and only the fields we want to index being added as separate fields at top level.
//
// This lets us keep the bleve index small in both size and complexity, as well as potentially speeding up the queries.
type ExcerptInDB struct {
	// Excerpt serialized & stored as JSON but not indexed
	E         string `json:"e"`
	Scripture string `json:"scripture"`
	SourceT   string `json:"source_t"`
	RomanT    string `json:"roman_t"`
	// Roman/IAST text stored as keyword to facilitate full regex searches
	RomanK string `json:"roman_k"`
	// Roman text but completely ASCII folded
	RomanF string `json:"roman_f"`

	// i.e readable index 1.1.4
	ViewIndex string `json:"view_index"`
	// Index with each number padded to 4 zeros
	SortIndex string `json:"sort_index"`

	// Auxiliary texts joined by space and other details omitted if any.
	Auxiliaries map[string]string `json:"auxiliaries"`

	Translation string `json:"translation"`

	// stuff we would want to do facetted search / query strings on. Keyword format.
	Addressees []string
	Notes      string
	Authors    []string
	Meter      string
	// All surfaces that have occurred in excerpt glossings. keyword analyzer again.
	Surfaces []string
}

type HierParent struct {
	Number   int
	FullPath string
	Type     string
}

type Hierarchy struct {
	Scripture *config.ScriptureDefn
	Path      []HierParent
	ChildType string
	Children  []int
	IsLeaf    bool
}

type HighlightedExcerpt struct {
	Excerpt       Excerpt
	SourceHl      string // Highlighted source text
	RomanHl       string // Highlighted roman text
	TranslationHl string // Highlighted translation text
	NotesHl       []string
}

// Type implements mapping.Classifier.
func (e *ExcerptInDB) Type() string {
	return "excerpt"
}

type ExcerptWithWords struct {
	Excerpt
	// Dict words indexed by morphological surface & lemma
	Words map[string]dictionary.DictionaryEntry
	Padas []PadaElement
}

type ExcerptTemplateData struct {
	Excerpts        []ExcerptWithWords
	Scripture       config.ScriptureDefn
	GlossingMap     map[string]WordGlossing
	AddressedTo     string
	Next            string
	Previous        string
	Up              string
	UpType          string
	GrammaticalTags map[string]common.GrammaticalTagStyle
}

type ExcerptSearchData struct {
	Excerpts  []HighlightedExcerpt
	Search    SearchParams
	Scripture config.ScriptureDefn
}

type QualifiedPath struct {
	Scripture string // Name of the scripture
	Path      []int  // Hierarchical path
}
