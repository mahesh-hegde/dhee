package templ_template

import (
	"fmt"
	"github.com/mahesh-hegde/dhee/app/common"
	"github.com/mahesh-hegde/dhee/app/excerpts"
	"strings"
)

func getTagStyle(tag common.GrammaticalTagStyle) string {
	var styles []string
	if tag.BackgroundColor != "" {
		styles = append(styles, "background-color: "+tag.BackgroundColor+" !important;")
	}
	if tag.Color != "" {
		styles = append(styles, "color: "+tag.Color+" !important;")
	}
	if tag.UnderlineStyle != "" && tag.UnderlineStyle != "none" {
		styles = append(styles, "text-decoration: underline; text-decoration-style: "+tag.UnderlineStyle+";")
	}
	return strings.Join(styles, " ")
}

func getTagClass(tag common.GrammaticalTagStyle) string {
	classes := []string{"badge", "me-1"}
	if tag.BackgroundColor == "" {
		classes = append(classes, "bg-secondary-subtle")
	}
	if tag.BorderStyle != "" && tag.BorderStyle != "none" {
		classes = append(classes, "border", "border-"+tag.BorderStyle)
	}
	return strings.Join(classes, " ")
}

templ grammaticalBadge(tagKey string, tags map[string]common.GrammaticalTagStyle) {
	if tagKey != "" {
		{{ tagStyle := tags[tagKey] }}
		<span class={ getTagClass(tagStyle) } style={ getTagStyle(tagStyle) } title={ fmt.Sprintf("%s (%s)", tagStyle.ReadableName, tagStyle.SanskritName) }>{ tagKey }</span>
	}
}

templ grammaticalBadges(g excerpts.WordGlossing, tags map[string]common.GrammaticalTagStyle) {
	@grammaticalBadge(g.Gramm, tags)
	if g.Root != "" {
		<span class="badge bg-secondary me-1" title="Root">{"âˆš" + g.Root}</span>
	}
	@grammaticalBadge(g.Number, tags)
	@grammaticalBadge(g.Gender, tags)
	@grammaticalBadge(g.Case, tags)
	@grammaticalBadge(g.Tense, tags)
	@grammaticalBadge(g.Voice, tags)
	@grammaticalBadge(g.Person, tags)
	@grammaticalBadge(g.Mood, tags)
	for _, mod := range g.Modifiers {
		<span class="badge bg-secondary me-1">{ string(mod) }</span>
	}
}

templ morphologyTable(data *excerpts.ExcerptTemplateData) {
	<div class="table-responsive">
		<table class="table table-sm table-striped align-middle">
			<thead>
				<tr>
					<th>Source index</th>
					<th>Surface</th>
					<th>Lemma</th>
					<th>Information</th>
				</tr>
			</thead>
			<tbody>
				for _, ew := range data.Excerpts {
					for rindex, row := range ew.Glossings {
						for windex, g := range row {
							<tr>
								<td class="text-muted small">{ ew.ReadableIndex }</td>
								<td>
									{{ surfEntry := ew.Words[g.Surface] }}
									if surfEntry.IAST != "" {
										<span class="table-word table-word-underline" data-word-id={ fmt.Sprintf("surf-%d-%d", rindex, windex) }>{ g.Surface }</span>
									} else {
										<span class="table-word" data-word-id={ fmt.Sprintf("surf-%d-%d", rindex, windex) }>{ g.Surface }</span>
									}
									<div id={ fmt.Sprintf("surf-%d-%d", rindex, windex) } class="table-word-data" style="display: none;">
										<div class="table-word-popup-content">
											if surfEntry.IAST != "" {
												for i, e := range surfEntry.Meanings {
													<div class="mb-2">
														<span class="dict-iast-surface"><em>{ surfEntry.IAST }</em></span>
														{ ": " }
														{ e.Body.Plain }
													</div>
													if i < len(surfEntry.Meanings)-1 {
														<hr/>
													}
												}
												<hr/>
											}
											<a href={ templ.URL(fmt.Sprintf("/dictionaries/monier-williams/search?q=%s&tl=iast&mode=prefix", g.Surface)) } class="badge bg-secondary">ðŸ”Ž { g.Surface }</a>
										</div>
									</div>
								</td>
								<td>
									{{ lemmaEntry := ew.Words[g.Lemma] }}
									if g.Lemma != "" {
										if lemmaEntry.Word != "" {
											<span class="table-word table-word-underline" data-word-id={ fmt.Sprintf("lemma-%d-%d", rindex, windex) }>{ g.Lemma }</span>
										} else {
											<span class="table-word" data-word-id={ fmt.Sprintf("lemma-%d-%d", rindex, windex) }>{ g.Lemma }</span>
										}
										<div id={ fmt.Sprintf("lemma-%d-%d", rindex, windex) } class="table-word-data" style="display: none;">
											<div class="table-word-popup-content">
												if lemmaEntry.Word != "" {
													for i, e := range lemmaEntry.Meanings {
														<div class="mb-2">
															<span class="dict-iast-lemma"><em>{ lemmaEntry.IAST }</em></span>
															{ ": " }
															{ e.Body.Plain }
														</div>
														if i < len(lemmaEntry.Meanings)-1 {
															<hr/>
														}
													}
													<hr/>
												}
												<a href={ templ.URL(fmt.Sprintf("/dictionaries/monier-williams/search?q=%s&tl=iast&mode=prefix", g.Lemma)) } class="badge bg-secondary">ðŸ”Ž { g.Lemma }</a>
											</div>
										</div>
									} else {
										<span class="text-muted">N/A</span>
									}
								</td>
								<td>
									@grammaticalBadges(g, data.GrammaticalTags)
								</td>
							</tr>
						}
					}
				}
			</tbody>
		</table>
	</div>
}
