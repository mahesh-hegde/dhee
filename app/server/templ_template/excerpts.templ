package templ_template

import (
	"fmt"
	"github.com/mahesh-hegde/dhee/app/config"
	"github.com/mahesh-hegde/dhee/app/excerpts"
)

func getKeys(s config.ScriptureDefn) []string {
	keys := []string{"SourceText", "RomanText", "aux-pada", "Notes"}
	for _, aux := range s.Auxiliaries {
		if aux.Name != "pada" {
			keys = append(keys, fmt.Sprintf("aux-%s", aux.Name))
		}
	}
	return keys
}

templ AuxiliaryCard(data *excerpts.ExcerptTemplateData, aux *config.AuxiliaryDefinition) {
	if auxText, ok := data.Excerpts[0].Auxiliaries[aux.Name]; ok && len(auxText.Text) > 0 {
		<div class="card" data-section-key={ "aux-" + aux.Name }>
			<div class="card-header">
				{ aux.ReadableName }
			</div>
			<div class="card-body">
				for _, excerpt := range data.Excerpts {
					<p><strong>{ excerpt.ReadableIndex }</strong></p>
					if auxiliary, ok := excerpt.Auxiliaries[aux.Name]; ok {
						for _, text := range auxiliary.Text {
							<p>{ text }</p>
						}
					}
				}
				if aux.Attribution != "" {
					<div class="text-end text-muted" style="font-size: 45%;">
						@templ.Raw(aux.Attribution)
					</div>
				}
			</div>
		</div>
	}
}

templ PadaCard(data *excerpts.ExcerptTemplateData, aux *config.AuxiliaryDefinition) {
	<div class="card" data-section-key="aux-pada">
		<div class="card-header">
			{ aux.ReadableName }
		</div>
		<div class="card-body">
			for eidx, excerpt := range data.Excerpts {
				<p><strong>{ excerpt.ReadableIndex }</strong></p>
				for pidx, pada := range excerpt.Padas {
					if pidx > 0 {
						{ ` | ` }
					}
					if pada.Found {
						{{ var dictLink string = "" }}
						if pada.SurfaceMeaning.Word != "" {
							{{ dictLink = pada.SurfaceMeaning.Word }}
						} else if pada.LemmaMeaning.Word != "" {
							{{ dictLink = pada.LemmaMeaning.Word }}
						}
						<span class="pada-word" data-pada-id={ fmt.Sprintf("pada-%d-%d", eidx, pidx) }>
							if dictLink != "" {
								<a href={ templ.URL(fmt.Sprintf("/dictionaries/monier-williams/words/%s", dictLink)) } class="text-decoration-none">
									if pada.ExactMatched {
										<strong>{ pada.Word }</strong>
									} else {
										{ pada.Word }
									}
								</a>
							} else {
								{ pada.Word }
							}
						</span>
						<div id={ fmt.Sprintf("pada-%d-%d", eidx, pidx) } class="pada-data" style="display: none;">
							<div class="pada-popup-content">
								<div class="mt-2">
									@grammaticalBadges(pada.G, data.GrammaticalTags)
								</div>
								if pada.G.Lemma != "" {
									<p>from <i>{ pada.G.Lemma }</i></p>
									<hr/>
								}
								if len(pada.SurfaceMeaning.Meanings) > 0 {
									<div class="mb-2">
										for _, entry := range pada.SurfaceMeaning.Meanings {
											<div class="mt-1">
												<span class="dict-iast-surface"><em>{ pada.SurfaceMeaning.IAST }</em></span>
												{ ": " }
												{ entry.Body.Plain }
											</div>
										}
										<hr/>
									</div>
								}
								if pada.LemmaMeaning.Word != "" {
									<div class="mb-2">
										for _, entry := range pada.LemmaMeaning.Meanings {
											<div class="mt-1">
												<span class="dict-iast-lemma"><em>{ pada.LemmaMeaning.IAST }</em></span>
												{ ": " }
												{ entry.Body.Plain }
											</div>
											<hr/>
										}
									</div>
								}
								<span class="d-flex justify-content-evenly">
									if pada.Slp1NormSurface != "" {
										<a href={ templ.URL(fmt.Sprintf("/dictionaries/monier-williams/search?q=%s&tl=slp1&mode=fuzzy", pada.Slp1NormSurface)) } class="badge bg-secondary me-1">ðŸ”Ž { pada.G.Surface }</a>
									}
									if pada.Slp1NormLemma != "" && pada.Slp1NormLemma != pada.Slp1NormSurface {
										<a href={ templ.URL(fmt.Sprintf("/dictionaries/monier-williams/search?q=%s&tl=slp1&mode=fuzzy", pada.Slp1NormLemma)) } class="badge bg-secondary me-1">ðŸ”Ž { pada.G.Lemma }</a>
									}
								</span>
							</div>
						</div>
					} else {
						<span>{ pada.Word }</span>
					}
				}
				<p></p>
			}
			if aux.Attribution != "" {
				<div class="text-end text-muted" style="font-size: 60%;">
					@templ.Raw(aux.Attribution)
				</div>
			}
		</div>
	</div>
}

templ Navigation(data *excerpts.ExcerptTemplateData) {
	<div class="d-flex justify-content-between my-4" style="font-size: 0.6em">
		if data.Previous != "" {
			<a href={ data.Previous } class="btn btn-sm btn-primary">&larr; Previous ({ data.Previous })</a>
		} else {
			<span></span>
		}
		if data.Up != "" {
			<a href={ data.Up } class="btn btn-sm btn-info">&uarr; { data.UpType } { data.Up }</a>
		}
		if data.Next != "" {
			<a href={ data.Next } class="btn btn-sm btn-primary">Next ({ data.Next }) &rarr;</a>
		} else {
			<span></span>
		}
	</div>
}

templ Excerpts(data *excerpts.ExcerptTemplateData) {
	<div class="container">
		@ScriptureSearchWidget(data.Scripture, nil)
		<script>
		const scriptureName = "{{ data.Scripture.Name }}";
		const scriptureKeys = {{ getKeys(data.Scripture) }};
		</script>
		if data != nil && len(data.Excerpts) > 0 {
			<div class="my-4">
				<h2 class="text-center">
					{ data.Scripture.ReadableName } { data.Excerpts[0].ReadableIndex }
					if len(data.Excerpts) > 1 {
						{ " - " }
						{ data.Excerpts[len(data.Excerpts)-1].ReadableIndex }
					}
				</h2>
			</div>
			<div class="d-flex flex-row justify-content-start my-3">
				<div class="d-flex justify-content-start me-2">
					<span class="badge bg-success">Addressed to: { data.AddressedTo }</span>
				</div>
				<div class="d-flex justify-content-start me-2">
					<span class="badge bg-secondary">Group: { data.Excerpts[0].Group }</span>
				</div>
			</div>
			<div id="cards-container" class="dual-column">
				<div class="card" data-section-key="SourceText">
					<div class="card-header">
						Text (Devanagari)
					</div>
					<div class="card-body" id="source-text-section">
						for _, excerpt := range data.Excerpts {
							<p><strong>{ excerpt.ReadableIndex }</strong></p>
							<div class="verse">
								for _, line := range excerpt.SourceText {
									<p class="line">{ line }</p>
								}
							</div>
						}
					</div>
				</div>
				<div class="card" data-section-key="RomanText">
					<div class="card-header">
						Text (Roman)
					</div>
					<div class="card-body verse" id="roman-text-section">
						for _, excerpt := range data.Excerpts {
							<p><strong>{ excerpt.ReadableIndex }</strong></p>
							for _, line := range excerpt.RomanText {
								<p class="roman-text">{ line }</p>
							}
						}
					</div>
				</div>
				for _, aux := range data.Scripture.Auxiliaries {
					if aux.Name == "pada" {
						@PadaCard(data, &aux)
					} else {
						@AuxiliaryCard(data, &aux)
					}
				}
				if data.Excerpts[0].Notes != nil {
					<div class="card" data-section-key="Notes">
						<div class="card-header">
							Notes
						</div>
						<div class="card-body">
							for _, excerpt := range data.Excerpts {
								if len(excerpt.Notes) > 0 {
									<p><strong>{ excerpt.ReadableIndex }</strong></p>
									for _, note := range excerpt.Notes {
										<div>
											@templ.Raw(note)
										</div>
									}
								}
							}
						</div>
					</div>
				}
			</div>
			<div class="card my-3">
				<div class="card-header d-flex justify-content-between align-items-center">
					<div>Grammatical analysis</div>
					<div>
						<button class="btn btn-sm btn-outline-info me-2" type="button" data-bs-toggle="collapse" data-bs-target="#grammaticalCollapse" aria-expanded="true" aria-controls="grammaticalCollapse">
							Toggle table
						</button>
					</div>
				</div>
				<div class="card-body collapse" id="grammaticalCollapse">
					@morphologyTable(data)
				</div>
			</div>
			<style>
		#cards-container.single-column {
			display: flex;
			flex-direction: column;
		}

		#cards-container.single-column .card {
			margin-top: 1rem;
			margin-bottom: 1rem;
		}

		#cards-container.dual-column {
			display: grid;
			grid-template-columns: 1fr;
			gap: 1rem;
			margin-top: 0;
		}

		@media (min-width: 992px) {
			#cards-container.dual-column {
				grid-template-columns: 1fr 1fr;
			}
		}

		#cards-container .card:last-child:nth-child(odd) {
			grid-column: 1 / -1;
		}
        .dotted-underline {
            border-bottom: 1px dotted currentColor;
            cursor: help;
        }
        .pada-word {
            cursor: pointer;
            position: relative;
        }

        .pada-popup {
            position: absolute;
            background: var(--bs-body-bg);
            color: var(--bs-body-color);
            border: 1px solid var(--bs-border-color);
            border-radius: 4px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            max-width: 400px;
            max-height: 40vh;
            overflow-y: auto;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .pada-word a {
            border-bottom: 1px dotted currentColor;
            text-decoration: none;
            cursor: help;
            color: var(--bs-body-color);
        }

        .table-word {
            cursor: pointer;
        }

        .table-word-underline {
            border-bottom: 1px dotted currentColor;
        }

        .table-word-popup {
            position: absolute;
            background: var(--bs-body-bg);
            color: var(--bs-body-color);
            border: 1px solid var(--bs-border-color);
            border-radius: 4px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            max-width: 400px;
            max-height: 40vh;
            overflow-y: auto;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .search-result-window {
            position: fixed;
            top: 10vh;
            left: 30vw;
            z-index: 1060;
            background-color: var(--bs-body-bg);
            color: var(--bs-body-color);
            border: 1px solid var(--bs-border-color);
            border-radius: .3rem;
            box-shadow: 0 .5rem 1rem rgba(0, 0, 0, .15);
            max-width: 40vw;
            max-height: 50vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .search-result-title-bar {
            height: 2em;
            background-color: #003300;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            flex-shrink: 0;
        }

        .search-result-content {
            padding: 1.5rem;
            overflow-y: auto;
        }

        .search-result-window .btn-close {
            margin-right: 0.5em;
            filter: invert(1) grayscale(100%) brightness(200%);
        }

		.pref-checkbox-item {
			cursor: move;
			padding: 0.25rem 0.5rem;
			border: 1px solid var(--bs-border-color);
			border-radius: 0.25rem;
			background: var(--bs-body-bg);
			user-select: none;
			white-space: nowrap;
		}

		.pref-checkbox-item:hover {
			background: var(--bs-secondary-bg);
		}

		.pref-checkbox-item.drag-over-before::before,
		.pref-checkbox-item.drag-over-after::after {
			content: '+';
			color: #0d6efd;
			font-weight: bold;
			padding: 0 0.25rem;
		}

		.pref-checkbox-item input {
			cursor: pointer;
		}

		.pref-checkbox-item.drag-over-before::before,
		.pref-checkbox-item.drag-over-after::after {
			content: '+';
			color: #0d6efd;
			font-weight: bold;
			padding: 0 0.25rem;
		}

		.pref-checkbox-item input {
			cursor: pointer;
		}

		#display-prefs {
			font-size: 0.7em;
		}
			</style>
			<script>
		const scripture = '{{ data.Scripture.Name }}';
		const setupOrderPrefs = function() {
			// Display preferences management
			var prefContainer = document.getElementById('display-prefs');
			if (!prefContainer) return;

			var checkboxItems = prefContainer.querySelectorAll('.pref-checkbox-item');
			var prefDraggedItem = null;

			// Enable checkboxes since JS is available
			checkboxItems.forEach(function(item) {
				item.querySelector('input').disabled = false;
			});

			// Load and apply saved preferences
			function loadPreferences() {
				if (typeof(Storage) === "undefined") {
					checkboxItems.forEach(function(item) {
						item.querySelector('input').disabled = true;
					});
					return;
				}
				
				try {
					var saved = localStorage.getItem('verseDisplayChoices/' + scripture);
					var order = JSON.parse(localStorage.getItem('verseDisplayOrder/' + scripture) || '[]');
					
					// Apply order first (before setting checkbox states)
					if (order.length > 0) {
						order.forEach(function(key) {
							var item = prefContainer.querySelector('[data-pref-key="' + key + '"]');
							if (item) prefContainer.appendChild(item);
						});
					}
					
					// Then apply checkbox states
					if (saved) {
						var prefs = JSON.parse(saved);
						Array.from(prefContainer.children).forEach(function(item) {
							if (!item.classList.contains('pref-checkbox-item')) return;
							var key = item.getAttribute('data-pref-key');
							var checkbox = item.querySelector('input');
							checkbox.checked = prefs.indexOf(key) !== -1;
						});
					}
					applyPreferences();
				} catch(e) {
					console.error('Failed to load preferences:', e);
				}
			}

			function savePreferences() {
				if (typeof(Storage) === "undefined") return;

				var enabled = [];
				var order = [];
				
				// Use childNodes or children to get actual DOM order, not querySelectorAll
				Array.from(prefContainer.children).forEach(function(item) {
					if (!item.classList.contains('pref-checkbox-item')) return;

					var key = item.getAttribute('data-pref-key');
					order.push(key);
					if (item.querySelector('input').checked) {
						enabled.push(key);
					}
				});

				localStorage.setItem('verseDisplayChoices/' + scripture, JSON.stringify(enabled));
				localStorage.setItem('verseDisplayOrder/' + scripture, JSON.stringify(order));
			}

			function applyPreferences() {
				var allSections = document.querySelectorAll('[data-section-key]');
				allSections.forEach(function(section) {
					section.style.display = 'none';
				});

				Array.from(prefContainer.children).forEach(function(item) {
					if (!item.classList.contains('pref-checkbox-item')) return;

					var key = item.getAttribute('data-pref-key');
					var checkbox = item.querySelector('input');
					if (checkbox.checked) {
						var section = document.querySelector('[data-section-key="' + key + '"]');
						if (section) section.style.display = 'block';
					}
				});
				
				// Reorder sections based on checkbox order
				var container = document.querySelector('.container');
				var firstSection = container.querySelector('[data-section-key]');
				if (!firstSection) return;
				
				var parent = firstSection.parentNode;
				Array.from(prefContainer.children).forEach(function(item) {
					if (!item.classList.contains('pref-checkbox-item')) return;

					var key = item.getAttribute('data-pref-key');
					var section = document.querySelector('[data-section-key="' + key + '"]');
					if (section && parent.contains(section)) {
						parent.appendChild(section); // Append in order
					}
				});
			}

			// Checkbox change handler
			checkboxItems.forEach(function(item) {
				var checkbox = item.querySelector('input');
				checkbox.addEventListener('change', function() {
					savePreferences();
					applyPreferences();
				});
			});

			// Drag and drop with early returns
			checkboxItems.forEach(function(item) {
				item.addEventListener('dragstart', function(e) {
					// Only handle if dragging from pref checkboxes
					if (!e.target.classList.contains('pref-checkbox-item')) {
						return;
					}
					
					prefDraggedItem = this;
					e.dataTransfer.effectAllowed = 'move';
					e.dataTransfer.setData('application/x-pref-checkbox', this.getAttribute('data-pref-key'));
				});
				
				item.addEventListener('dragover', function(e) {
					// Only respond to our drag type
					if (!e.dataTransfer.types.includes('application/x-pref-checkbox')) {
						return;
					}
					if (prefDraggedItem === this) return;
					
					e.preventDefault();
					
					var rect = this.getBoundingClientRect();
					var midpoint = rect.left + rect.width / 2;
					
					prefContainer.querySelectorAll('.pref-checkbox-item').forEach(function(i) {
						i.classList.remove('drag-over-before', 'drag-over-after');
					});
					
					if (e.clientX < midpoint) {
						this.classList.add('drag-over-before');
					} else {
						this.classList.add('drag-over-after');
					}
				});
				
				item.addEventListener('dragleave', function(e) {
					// Only handle our drag type
					if (!e.dataTransfer.types.includes('application/x-pref-checkbox')) {
						return;
					}
					
					this.classList.remove('drag-over-before', 'drag-over-after');
				});
				
				item.addEventListener('drop', function(e) {
					var key = e.dataTransfer.getData('application/x-pref-checkbox');
					if (!key) return; // Not our drag type
					if (prefDraggedItem === this) return;
					
					e.preventDefault();
					
					var rect = this.getBoundingClientRect();
					var midpoint = rect.left + rect.width / 2;
					
					if (e.clientX < midpoint) {
						prefContainer.insertBefore(prefDraggedItem, this);
					} else {
						prefContainer.insertBefore(prefDraggedItem, this.nextSibling);
					}
					
					this.classList.remove('drag-over-before', 'drag-over-after');
					savePreferences();
					applyPreferences();
				});
				
				item.addEventListener('dragend', function(e) {
					// Only handle our drag type
					if (!e.dataTransfer.types.includes('application/x-pref-checkbox')) {
						return;
					}
					
					prefContainer.querySelectorAll('.pref-checkbox-item').forEach(function(i) {
						i.classList.remove('drag-over-before', 'drag-over-after');
					});
				});
			});

			loadPreferences();
		}

		const setupLayoutPrefs = function() {
			// Layout preferences
			const layoutRadios = document.querySelectorAll('input[name="layout"]');
			layoutRadios.forEach(function(radio) {
				radio.disabled = false;
				radio.addEventListener('change', function() {
					const container = document.getElementById('cards-container');
					if (this.value === 'single') {
						container.classList.remove('dual-column');
						container.classList.add('single-column');
					} else {
						container.classList.remove('single-column');
						container.classList.add('dual-column');
					}
					
					if (typeof(Storage) !== "undefined") {
						localStorage.setItem('layoutPref/' + scripture, this.value);
					}
				});
			});

			// Load saved layout preference
			if (typeof(Storage) !== "undefined") {
				const savedLayout = localStorage.getItem('layoutPref/' + scripture);
				if (savedLayout) {
					const radio = document.querySelector('input[name="layout"][value="' + savedLayout + '"]');
					if (radio) {
						radio.checked = true;
						const container = document.getElementById('cards-container');
						container.classList.remove('single-column', 'dual-column');
						container.classList.add(savedLayout === 'single' ? 'single-column' : 'dual-column');
					}
				}
			}
		}

        // Pada word popup handler and table word popup handler
        // initFn will be called by layout body after bootstrap is loaded. This way we can keep JS loading in the end.
        const initFn = (function () {
            var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
            tooltipTriggerList.forEach(function (tooltipTriggerEl) {
                new bootstrap.Tooltip(tooltipTriggerEl)
            })

            var activePopup = null;

            // Pada word hover cards
            document.querySelectorAll('.pada-word').forEach(function (wordEl) {
                var padaId = wordEl.getAttribute('data-pada-id');
                var dataEl = document.getElementById(padaId);

                if (!dataEl) return;

                wordEl.addEventListener('mouseenter', function (e) {
                    // Remove any existing popup
                    if (activePopup) {
                        activePopup.remove();
                        activePopup = null;
                    }

                    // Create popup
                    var popup = document.createElement('div');
                    popup.className = 'pada-popup';
                    popup.innerHTML = dataEl.querySelector('.pada-popup-content').innerHTML;

                    // Position popup
                    document.body.appendChild(popup);
                    var rect = wordEl.getBoundingClientRect();
                    popup.style.left = rect.left + 'px';
                    popup.style.top = (rect.bottom + window.scrollY + 5) + 'px';

                    activePopup = popup;
                });

                wordEl.addEventListener('mouseleave', function (e) {
                    setTimeout(function () {
                        if (activePopup && !activePopup.matches(':hover')) {
                            activePopup.remove();
                            activePopup = null;
                        }
                    }, 100);
                });
            });

            // Table word hover cards
            document.querySelectorAll('.table-word').forEach(function (wordEl) {
                var wordId = wordEl.getAttribute('data-word-id');
                var dataEl = document.getElementById(wordId);

                if (!dataEl) return;

                wordEl.addEventListener('mouseenter', function (e) {
                    // Remove any existing popup
                    if (activePopup) {
                        activePopup.remove();
                        activePopup = null;
                    }

                    // Create popup
                    var popup = document.createElement('div');
                    popup.className = 'table-word-popup';
                    popup.innerHTML = dataEl.querySelector('.table-word-popup-content').innerHTML;

                    // Position popup
                    document.body.appendChild(popup);
                    var rect = wordEl.getBoundingClientRect();
                    popup.style.left = rect.left + 'px';
                    popup.style.top = (rect.bottom + window.scrollY + 5) + 'px';

                    activePopup = popup;
                });

                wordEl.addEventListener('mouseleave', function (e) {
                    setTimeout(function () {
                        if (activePopup && !activePopup.matches(':hover')) {
                            activePopup.remove();
                            activePopup = null;
                        }
                    }, 100);
                });
            });

            function makeDraggable(element) {
                let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
                const dragHandle = element.querySelector('.search-result-title-bar');
                if (!dragHandle) { return; }
                dragHandle.onmousedown = dragMouseDown;

                function dragMouseDown(e) {
                    if (e.target.tagName === 'A' || e.target.tagName === 'BUTTON' || e.target.closest('a, button')) {
                        return;
                    }
                    e = e || window.event;
                    e.preventDefault();
                    pos3 = e.clientX;
                    pos4 = e.clientY;
                    document.onmouseup = closeDragElement;
                    document.onmousemove = elementDrag;
                }

                function elementDrag(e) {
                    e = e || window.event;
                    e.preventDefault();
                    pos1 = pos3 - e.clientX;
                    pos2 = pos4 - e.clientY;
                    pos3 = e.clientX;
                    pos4 = e.clientY;
                    element.style.top = (element.offsetTop - pos2) + "px";
                    element.style.left = (element.offsetLeft - pos1) + "px";
                }

                function closeDragElement() {
                    document.onmouseup = null;
                    document.onmousemove = null;
                }
            }

            // Text selection search popup
            function setupTextSelectionSearch(elementId, transliteration, fuzziness) {
                const textEl = document.getElementById(elementId);
                if (!textEl) return;

                textEl.addEventListener('mouseup', function (e) {
                    const searchResultWindow = document.querySelector('.search-result-window');
                    if (searchResultWindow && searchResultWindow.contains(e.target)) {
                        return;
                    }

                    if (activePopup) {
                        activePopup.remove();
                        activePopup = null;
                    }

                    setTimeout(() => {
                        const selection = window.getSelection();
                        if (!selection.rangeCount) return;
                        const selectedText = selection.toString().trim();

                        if (selectedText.length > 0 && (selectedText.match(/\s/g) || []).length <= 2) {
                            const range = selection.getRangeAt(0);
                            const rect = range.getBoundingClientRect();

                            if (e.target.closest('.pada-popup, .table-word-popup, .roman-selection-popup')) return;

                            const popup = document.createElement('div');
                            popup.className = 'roman-selection-popup';
                            popup.style.position = 'absolute';
                            popup.style.zIndex = 1050;

                            const searchBadge = document.createElement('button');
                            searchBadge.className = 'btn btn-sm btn-info';
                            searchBadge.innerHTML = `ðŸ”Ž ${selectedText}`;

                            popup.appendChild(searchBadge);
                            document.body.appendChild(popup);

                            const popupRect = popup.getBoundingClientRect();
                            popup.style.left = `${rect.right + window.scrollX - popupRect.width}px`;
                            popup.style.top = `${rect.bottom + window.scrollY + 5}px`;

                            activePopup = popup;

                            searchBadge.addEventListener('click', function () {
                                if (activePopup) {
                                    activePopup.remove();
                                    activePopup = null;
                                }

                                const existingResultWindow = document.querySelector('.search-result-window');
                                if (existingResultWindow) {
                                    existingResultWindow.remove();
                                }

                                const url = `/dictionaries/monier-williams/search?q=${encodeURIComponent(selectedText)}&tl=${transliteration}&mode=fuzzy&preview=true&fuzziness=${fuzziness}`;
                                fetch(url)
                                    .then(response => response.text())
                                    .then(html => {
                                        const resultWindow = document.createElement('div');
                                        resultWindow.className = 'search-result-window';

                                        const titleBar = document.createElement('div');
                                        titleBar.className = 'search-result-title-bar';

                                        const closeButton = document.createElement('button');
                                        closeButton.className = 'btn-close';
                                        closeButton.setAttribute('aria-label', 'Close');
                                        titleBar.appendChild(closeButton);

                                        const contentDiv = document.createElement('div');
                                        contentDiv.className = 'search-result-content';
                                        contentDiv.innerHTML = html;

                                        resultWindow.appendChild(titleBar);
                                        resultWindow.appendChild(contentDiv);

                                        document.body.appendChild(resultWindow);

                                        closeButton.onclick = function () {
                                            resultWindow.remove();
                                        };

                                        makeDraggable(resultWindow);
                                    }).catch(err => console.error("Failed to fetch search preview:", err));
                            });
                        }
                    }, 10);
                });
            }
            setupTextSelectionSearch('roman-text-section', 'iast', 2);
            setupTextSelectionSearch('source-text-section', 'dn', 3);

            // Close popup when clicking outside
            document.addEventListener('click', function (e) {
                if (activePopup && !activePopup.contains(e.target) && !e.target.closest('.pada-word') && !e.target.closest('.table-word')) {
                    activePopup.remove();
                    activePopup = null;
                }

                const resultWindow = document.querySelector('.search-result-window');
                if (resultWindow && !resultWindow.contains(e.target) && !e.target.closest('.roman-selection-popup')) {
                    resultWindow.remove();
                }
            });

			try {
				setupOrderPrefs();
				setupLayoutPrefs()
			} catch (e) {
				console.error("Failed to setup display order preferences:", e);
			}
        });
			</script>
			<div class="d-flex flex-row">
				<div id="display-prefs" class="d-flex flex-wrap justify-content-start gap-2" style="max-width: 80%;">
					<label class="pref-checkbox-item" draggable="true" data-pref-key="SourceText">
						<input type="checkbox" checked disabled class="me-1"/>
						<span>Devanagari</span>
					</label>
					<label class="pref-checkbox-item" draggable="true" data-pref-key="RomanText">
						<input type="checkbox" checked disabled class="me-1"/>
						<span>Roman</span>
					</label>
					for _, aux := range data.Scripture.Auxiliaries {
						<label class="pref-checkbox-item" draggable="true" data-pref-key={ "aux-" + aux.Name }>
							<input type="checkbox" checked disabled class="me-1"/>
							<span>{ aux.ReadableName }</span>
						</label>
					}
					<label class="pref-checkbox-item" draggable="true" data-pref-key="Notes">
						<input type="checkbox" checked disabled class="me-1"/>
						<span>Notes</span>
					</label>
				</div>
			</div>
			<div class="d-flex justify-content-start mt-2">
				<div id="layout-prefs" class="d-flex align-items-center gap-3" style="font-size: 0.7em;">
					<label class="form-check-label">
						<input type="radio" name="layout" value="single" disabled class="form-check-input me-1"/>
						<span>Single column</span>
					</label>
					<label class="form-check-label">
						<input type="radio" name="layout" value="dual" checked disabled class="form-check-input me-1"/>
						<span>Dual column</span>
					</label>
				</div>
			</div>
			@Navigation(data)
			if data.Scripture.Attribution != "" {
				<div class="text-center my-4 text-muted" style="font-size: 60%;">
					@templ.Raw(data.Scripture.Attribution)
				</div>
			}
		} else {
			<div class="alert alert-warning mt-4" role="alert">
				No results found!
			</div>
		}
	</div>
	@SearchScript()
}
